"""
Django settings for pymap project.

Generated by 'django-admin startproject' using Django 5.0.1.

For more information on this file, see
https://docs.djangoproject.com/en/5.0/topics/settings/

For the full list of settings and their values, see
https://docs.djangoproject.com/en/5.0/ref/settings/
"""
import json
import os
from pathlib import Path
from typing import Dict, List
from django.core.management.utils import get_random_secret_key

# Build paths inside the project like this: BASE_DIR / 'subdir'.
BASE_DIR: Path = Path(__file__).resolve().parent.parent
DJANGO_ENV: str = os.environ.get("DJANGO_ENV", "production")


# Quick-start development settings - unsuitable for production
# See https://docs.djangoproject.com/en/5.0/howto/deployment/checklist/

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = None

# SECURITY WARNING: don't run with debug turned on in production!
DEBUG: bool = True if DJANGO_ENV == "development" else False

if DEBUG:
    # We use print logging is not yet configured
    print(
        f"""WARNING: Debug is turned on, if running in production,
          change the value of the environment variable to production,
          current value: DJANGO_ENV={DJANGO_ENV}"""
    )

ALLOWED_HOSTS: List[str] = [
    # ...
    "127.0.0.1",
    "pymap",
    "pymap-server"
    # ...
]

# The Debug Toolbar is shown only if your IP address is listed in Djangoâ€™s INTERNAL_IPS setting.
INTERNAL_IPS: List[str] = [
    # ...
    "127.0.0.1",
    # ...
]

# Application definition

INSTALLED_APPS = [
    "migrator",
    "django_celery_results",
    "django.contrib.admin",
    "django.contrib.admindocs",
    "django.contrib.auth",
    "django.contrib.contenttypes",
    "django.contrib.sessions",
    "django.contrib.messages",
    "django.contrib.staticfiles",
] + (["debug_toolbar"] if DEBUG else [])

MIDDLEWARE = [
    "django.middleware.security.SecurityMiddleware",
    "django.contrib.sessions.middleware.SessionMiddleware",
    "django.middleware.common.CommonMiddleware",
    "django.middleware.csrf.CsrfViewMiddleware",
    "django.contrib.auth.middleware.AuthenticationMiddleware",
    "django.contrib.messages.middleware.MessageMiddleware",
    "django.middleware.clickjacking.XFrameOptionsMiddleware",
] + (["debug_toolbar.middleware.DebugToolbarMiddleware"] if DEBUG else [])

ROOT_URLCONF = "pymap.urls"

TEMPLATES = [
    {
        "BACKEND": "django.template.backends.django.DjangoTemplates",
        "DIRS": [],
        "APP_DIRS": True,
        "OPTIONS": {
            "context_processors": [
                "django.template.context_processors.debug",
                "django.template.context_processors.request",
                "django.contrib.auth.context_processors.auth",
                "django.contrib.messages.context_processors.messages",
            ],
        },
    },
]

WSGI_APPLICATION = "pymap.wsgi.application"


# Database
# https://docs.djangoproject.com/en/5.0/ref/settings/#databases

DATABASES = {
    "default": {
        "ENGINE": "django.db.backends.sqlite3",
        "NAME": BASE_DIR / "db.sqlite3",
    }
}


# Password validation
# https://docs.djangoproject.com/en/5.0/ref/settings/#auth-password-validators

AUTH_PASSWORD_VALIDATORS = [
    {
        "NAME": "django.contrib.auth.password_validation.UserAttributeSimilarityValidator",
    },
    {
        "NAME": "django.contrib.auth.password_validation.MinimumLengthValidator",
    },
    {
        "NAME": "django.contrib.auth.password_validation.CommonPasswordValidator",
    },
    {
        "NAME": "django.contrib.auth.password_validation.NumericPasswordValidator",
    },
]


# Internationalization
# https://docs.djangoproject.com/en/5.0/topics/i18n/
# TODO: consider adding internationalization
LANGUAGE_CODE = "en-us"

TIME_ZONE = "Europe/Lisbon"

USE_I18N = True

USE_TZ = True


# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/5.0/howto/static-files/

STATIC_URL = "static/"
STATIC_ROOT = "/home/pymap/app/static"

# Default primary key field type
# https://docs.djangoproject.com/en/5.0/ref/settings/#default-auto-field

DEFAULT_AUTO_FIELD = "django.db.models.BigAutoField"

# This should match the name of your login URL pattern
# This setting specifies the URL where the user will be redirected
# if they are not authenticated and try to access a protected view.
LOGIN_URL = "/login/"
LOGIN_REDIRECT_URL = "sync/"

# Celery configuration
CELERY_BROKER_URL = "redis://localhost:6379/0"
CELERY_RESULT_BACKEND = "redis://localhost:6379/0"
CELERY_TIMEZONE = "Europe/Lisbon"
CELERY_TASK_TRACK_STARTED = True
CELERY_ACCEPT_CONTENT = ["json"]
CELERY_TASK_SERIALIZER = "json"
CELERY_RESULT_SERIALIZER = "json"
# TODO: Check if this setting does not expose any data that it shouldn't
CELERY_RESULT_EXTENDED = True

# Initial logging configuration
LOGGING = {
    "version": 1,
    "disable_existing_loggers": False,
    "handlers": {
        "console": {
            "class": "logging.StreamHandler",
        },
    },
    "root": {
        "handlers": ["console"],
        "level": "INFO",
    },
}

# Application's log directory

PYMAP_LOGDIR = None

# Custom settings
PYMAP_SETTINGS: Dict[str, str] = {}


def load_settings_file() -> None:
    """
    Load custom settings from a JSON file.

    Raises:
        FileNotFoundError: If the configuration file is not found.
        json.JSONDecodeError: If the configuration file is not valid JSON.
    """
    global PYMAP_SETTINGS
    config_file = "config.json" if DJANGO_ENV == "production" else "config.dev.json"
    custom_settings = {}
    with open(os.path.join(BASE_DIR, config_file)) as f:
        custom_settings = json.load(f)

    print(f"Loaded custom settings from {os.path.join(BASE_DIR, config_file)}")

    log_config = custom_settings.get("LOGGING", {})

    # Override the LOGGING config with the user supplied if it exists
    if isinstance(log_config, dict) and len(log_config) > 0:
        LOGGING.update(log_config)

    databases_config = custom_settings.get("DATABASES", {})

    # Override the DATABASES config with the user supplied if it exists
    if isinstance(databases_config, dict) and len(databases_config) > 0:
        DATABASES.update(databases_config)

    # Store custom settings under a specific key in PYMAP_SETTINGS
    # I don't think anything besides the app should access the database settings
    # so they are excluded for now
    PYMAP_SETTINGS.update(
        {k: v for k, v in custom_settings.items() if k != "DATABASES"}
    )


# TODO: Add a better way to check complexity of SECRET_KEY
def load_key_file() -> None:
    """
    Load the SECRET_KEY from a .secret file.

    Raises:
        ValueError: If the loaded SECRET_KEY is too short.
    """
    global SECRET_KEY
    if os.path.isfile(".secret"):
        with open(".secret", "r", encoding="utf-8") as fh:
            read_key: str = fh.read().strip()
            if len(read_key) > 10:
                SECRET_KEY = read_key
            else:
                raise ValueError("The loaded SECRET_KEY is too short.")


def load_settings_env() -> None:
    """
    Load custom environment variables into global variables.

    This function loads specific environment variables into global variables if they are defined.
    The environment variables to be loaded are specified in the SETTINGS list.
    If any of these environment variables are found, they are assigned to the corresponding
    global variables in the current namespace.

    Returns:
        None
    """
    SETTINGS = [
        "CELERY_BROKER_URL",
        "CELERY_RESULT_BACKEND",
        "STATIC_ROOT",
        "PYMAP_LOGDIR"
    ]
    custom_settings = {v: os.getenv(v) for v in SETTINGS if os.getenv(v)}

    if len(custom_settings.keys()) > 0:
        for key, value in custom_settings.items():
            if key and value:
                print(f"LOADED {key}={value[:2]}...")
                globals()[key] = value


def check_log_directory() -> None:
    """
    Check if the log directory exists and is readable/writable.

    Raises:
        FileNotFoundError: If the log directory does not exist.
        PermissionError: If the log directory is not readable or writable.
    """
    global PYMAP_LOGDIR
    _default = "/var/log/pymap" if DJANGO_ENV == "production" else "pymap_logs"
    _env = os.environ.get("PYMAP_LOGDIR", None)
    PYMAP_LOGDIR = _env if _env else PYMAP_SETTINGS.get("LOGDIR", _default)
    if not os.path.exists(PYMAP_LOGDIR):
        raise FileNotFoundError(f"The log directory {PYMAP_LOGDIR} does not exist.")
    if not os.access(PYMAP_LOGDIR, os.W_OK) or not os.access(PYMAP_LOGDIR, os.R_OK):
        raise PermissionError(
            f"The log directory {PYMAP_LOGDIR} is not readable/writable."
        )


def verify_secret_key() -> None:
    """
    Verify the SECRET_KEY is provided and set to an appropriate value.

    Raises:
        ValueError: If SECRET_KEY is missing in production environment.
    """
    global SECRET_KEY
    if SECRET_KEY is None and DJANGO_ENV == "production":
        raise ValueError(
            "You need to provide SECRET_KEY from either the config.json file or a .secret file in the app directory"
        )
    elif SECRET_KEY is None and DJANGO_ENV != "production":
        SECRET_KEY = get_random_secret_key()
        print("Generated new secret key %s", SECRET_KEY)


# Load custom settings, secret file, and env variables
load_settings_file()
load_key_file()
load_settings_env()
# Call the check_log_directory function during startup
check_log_directory()
# Check the SECRET_KEY during startup
verify_secret_key()
