"""
Django settings for pymap project.

Generated by 'django-admin startproject' using Django 5.0.1.

For more information on this file, see
https://docs.djangoproject.com/en/5.0/topics/settings/

For the full list of settings and their values, see
https://docs.djangoproject.com/en/5.0/ref/settings/
"""
import json
import os
import errno
from pathlib import Path
import sys
from typing import Dict, List
from django.core.management.utils import get_random_secret_key

# Build paths inside the project like this: BASE_DIR / 'subdir'.
BASE_DIR: Path = Path(__file__).resolve().parent.parent
DJANGO_ENV: str = os.environ.get("DJANGO_ENV", "production")


# Quick-start development settings - unsuitable for production
# See https://docs.djangoproject.com/en/5.0/howto/deployment/checklist/

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = None

# SECURITY WARNING: don't run with debug turned on in production!
DEBUG: bool = True if DJANGO_ENV == "development" else False

if DEBUG:
    # We use print logging is not yet configured
    print(
        f"""WARNING: Debug is turned on, if running in production,
          change the value of the environment variable to production,
          current value: DJANGO_ENV={DJANGO_ENV}"""
    )

ALLOWED_HOSTS: List[str] = []

CSRF_TRUSTED_ORIGINS: List[str] = []

# The Debug Toolbar is shown only if your IP address is listed in Djangoâ€™s INTERNAL_IPS setting.
INTERNAL_IPS: List[str] = [
    # ...
    "127.0.0.1",
    # ...
]

# Application definition

INSTALLED_APPS = [
    "migrator",
    "django_celery_results",
    "django.contrib.admin",
    "django.contrib.admindocs",
    "django.contrib.auth",
    "django.contrib.contenttypes",
    "django.contrib.sessions",
    "django.contrib.messages",
    "django.contrib.staticfiles",
    "django_celery_beat",
] + (["debug_toolbar"] if DEBUG else [])

MIDDLEWARE = [
    "django.middleware.security.SecurityMiddleware",
    "django.middleware.cache.UpdateCacheMiddleware",
    "django.contrib.sessions.middleware.SessionMiddleware",
    "django.middleware.common.CommonMiddleware",
    "django.middleware.csrf.CsrfViewMiddleware",
    "django.contrib.auth.middleware.AuthenticationMiddleware",
    "django.contrib.messages.middleware.MessageMiddleware",
    "django.middleware.clickjacking.XFrameOptionsMiddleware",
    "migrator.middleware.require_auth.staff_only",
    "django.middleware.cache.FetchFromCacheMiddleware",
] + (["debug_toolbar.middleware.DebugToolbarMiddleware"] if DEBUG else [])

ROOT_URLCONF = "pymap.urls"

TEMPLATES = [
    {
        "BACKEND": "django.template.backends.django.DjangoTemplates",
        "DIRS": [],
        "APP_DIRS": True,
        "OPTIONS": {
            "context_processors": [
                "django.template.context_processors.debug",
                "django.template.context_processors.request",
                "django.contrib.auth.context_processors.auth",
                "django.contrib.messages.context_processors.messages",
            ],
        },
    },
]

WSGI_APPLICATION = "pymap.wsgi.application"


# Database
# https://docs.djangoproject.com/en/5.0/ref/settings/#databases

DATABASES = {
    "default": {
        "ENGINE": "django.db.backends.sqlite3",
        "NAME": BASE_DIR / "db.sqlite3",
    }
}

# Cache
# https://docs.djangoproject.com/en/5.0/topics/cache/
CACHES = {
    "default": {
        "BACKEND": "django.core.cache.backends.redis.RedisCache",
        "LOCATION": "redis://redis:6379",
    }
}
CACHE_MIDDLEWARE_SECONDS = 3600
if DJANGO_ENV == "development":
    CACHES = {
        "default": {
            "BACKEND": "django.core.cache.backends.dummy.DummyCache",
        }
    }


# Password validation
# https://docs.djangoproject.com/en/5.0/ref/settings/#auth-password-validators

AUTH_PASSWORD_VALIDATORS = [
    {
        "NAME": "django.contrib.auth.password_validation.UserAttributeSimilarityValidator",
    },
    {
        "NAME": "django.contrib.auth.password_validation.MinimumLengthValidator",
    },
    {
        "NAME": "django.contrib.auth.password_validation.CommonPasswordValidator",
    },
    {
        "NAME": "django.contrib.auth.password_validation.NumericPasswordValidator",
    },
]


# Internationalization
# https://docs.djangoproject.com/en/5.0/topics/i18n/
# TODO: consider adding internationalization
LANGUAGE_CODE = "en-us"

TIME_ZONE = "Europe/Lisbon"

USE_I18N = True

USE_TZ = True


# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/5.0/howto/static-files/

STATIC_URL = "static/"
STATIC_ROOT = os.environ.get("STATIC_ROOT", Path(BASE_DIR, "static"))

# Default primary key field type
# https://docs.djangoproject.com/en/5.0/ref/settings/#default-auto-field

DEFAULT_AUTO_FIELD = "django.db.models.BigAutoField"

# This should match the name of your login URL pattern
# This setting specifies the URL where the user will be redirected
# if they are not authenticated and try to access a protected view.
LOGIN_URL = "/login/"
LOGIN_REDIRECT_URL = "sync/"

# Celery configuration
CELERY_BROKER_URL = "redis://localhost:6379/0"
CELERY_RESULT_BACKEND = "redis://localhost:6379/1"
CELERY_TIMEZONE = "Europe/Lisbon"
CELERY_TASK_TRACK_STARTED = True
CELERY_ACCEPT_CONTENT = ["json"]
CELERY_TASK_SERIALIZER = "json"
CELERY_RESULT_SERIALIZER = "json"
# TODO: Check if this setting does not expose any data that it shouldn't
CELERY_RESULT_EXTENDED = True

# Initial logging configuration
LOGGING = {
    "version": 1,
    "disable_existing_loggers": False,
    "handlers": {
        "console": {
            "class": "logging.StreamHandler",
        },
    },
    "root": {
        "handlers": ["console"],
        "level": "INFO",
    },
}

# Application's log directory

PYMAP_LOGDIR = "pymap_logs"

# Custom settings
PYMAP_SETTINGS: Dict[str, str] = {}


def load_settings_file() -> None:
    """
    Load custom settings from a JSON file.
    """
    global PYMAP_SETTINGS, LOGGING, ALLOWED_HOSTS, CSRF_TRUSTED_ORIGINS, CACHES, CACHE_MIDDLEWARE_SECONDS
    config_file = "config.json" if DJANGO_ENV == "production" else "config.dev.json"
    custom_settings = {}
    try:
        if not Path(config_file).exists():
            raise FileNotFoundError(
                errno.ENOENT, os.strerror(errno.ENOENT), config_file
            )
        with open(Path(BASE_DIR, config_file)) as f:
            custom_settings = json.load(f)
    except (json.JSONDecodeError, FileNotFoundError) as e:
        print(f"Failed to load config file from: {config_file}, reason: {e}")
        sys.exit(1)

    print(f"Loaded custom settings from: {Path(BASE_DIR, config_file)}")

    # Override the LOGGING config with the user supplied if it exists
    log_config = custom_settings.get("LOGGING", {})
    if isinstance(log_config, dict) and len(log_config) > 0:
        LOGGING.update(log_config)

    # Override the DATABASES config with the user supplied if it exists
    databases_config = custom_settings.get("DATABASES", {})
    if isinstance(databases_config, dict) and len(databases_config) > 0:
        DATABASES.update(databases_config)

    # Override the CACHES config with the user supplied if it exists
    caches_config = custom_settings.get("CACHES", {})
    caches_seconds = custom_settings.get("CACHE_MIDDLEWARE_SECONDS", 3600)
    if isinstance(caches_config, dict) and len(caches_config) > 0:
        CACHES.update(caches_config)
    if isinstance(caches_seconds, int):
        CACHE_MIDDLEWARE_SECONDS = caches_seconds

    # Update ALLOWED_HOSTS
    new_hosts = custom_settings.get("ALLOWED_HOSTS", [])
    if isinstance(new_hosts, List) and len(new_hosts) > 0:
        ALLOWED_HOSTS = new_hosts

    # Update CSRF_TRUSTED_ORIGINS
    new_origins = custom_settings.get("CSRF_TRUSTED_ORIGINS", [])
    if isinstance(new_origins, List) and len(new_origins) > 0:
        CSRF_TRUSTED_ORIGINS = new_origins

    # Store custom settings under a specific key in PYMAP_SETTINGS
    # I don't think anything besides django should access the database settings
    # we only include settings the app should access
    PYMAP_SETTINGS.update(
        {k: v for k, v in custom_settings.items() if k in ["PYMAP_LOGDIR", "HOSTS"]}
    )


# TODO: Add a better way to check complexity of SECRET_KEY
def load_key_file() -> None:
    """
    Load the SECRET_KEY from a .secret file.

    Raises:
        FileNotFoundError: If the file is missing.
        ValueError: If the loaded SECRET_KEY is too short.
        OSError: When it fails to open the file
    """
    global SECRET_KEY
    try:
        if not Path(".secret").is_file() and DJANGO_ENV == "production":
            raise FileNotFoundError(f'File {Path("./", ".secret")} was not found')
        with open(".secret", "r", encoding="utf-8") as fh:
            read_key: str = fh.read().strip()
            if len(read_key) > 10:
                SECRET_KEY = read_key
            else:
                raise ValueError("The loaded SECRET_KEY is too short.")
    except (OSError, FileNotFoundError, ValueError) as e:
        print(f"Failed to load secret file: {e}")
        sys.exit(1)


def load_settings_env() -> None:
    """
    Load custom environment variables into global variables.

    This function loads specific environment variables into global variables if they are defined.
    The environment variables to be loaded are specified in the SETTINGS list.
    If any of these environment variables are found, they are assigned to the corresponding
    global variables in the current namespace.

    Returns:
        None
    """
    global ALLOWED_HOSTS, CSRF_TRUSTED_ORIGINS
    SETTINGS = [
        "CELERY_BROKER_URL",
        "CELERY_RESULT_BACKEND",
        "CELERY_CACHE_BACKEND",
        "STATIC_ROOT",
        "PYMAP_LOGDIR",
    ]
    custom_settings = {v: os.getenv(v) for v in SETTINGS if os.getenv(v)}

    if len(custom_settings.keys()) == 0:
        return
    for key, value in custom_settings.items():
        if key and value:
            print(f"LOADED {key}={value[:2]}...")
            globals()[key] = value

    # add PYMAP_HOSTNAME to ALLOWED_HOSTS and CSRF_TRUSTED_ORIGINS
    hostname = os.getenv("PYMAP_HOSTNAME")
    if hostname:
        ALLOWED_HOSTS.append(hostname)
        CSRF_TRUSTED_ORIGINS.append(f"https://{hostname}")


def check_log_directory() -> None:
    """
    Check if the log directory exists and is readable/writable.

    Raises:
        FileNotFoundError: If the log directory does not exist.
        PermissionError: If the log directory is not readable or writable.
    """
    global PYMAP_LOGDIR
    _default = "/var/log/pymap" if DJANGO_ENV == "production" else "pymap_logs"
    _env = os.environ.get("PYMAP_LOGDIR", None)
    PYMAP_LOGDIR = _env if _env else PYMAP_SETTINGS.get("PYMAP_LOGDIR", _default)
    # Just to ease usage in development
    if DJANGO_ENV == "development":
        Path(PYMAP_LOGDIR).mkdir(parents=True, exist_ok=True)
    try:
        if not Path(PYMAP_LOGDIR).exists():
            raise FileNotFoundError(
                errno.ENOENT,
                os.strerror(errno.ENOENT),
                f"The log directory {PYMAP_LOGDIR} does not exist.",
            )
        if not os.access(PYMAP_LOGDIR, os.W_OK) or not os.access(PYMAP_LOGDIR, os.R_OK):
            raise PermissionError(
                f"The log directory {PYMAP_LOGDIR} is not readable/writable."
            )
    except (FileNotFoundError, PermissionError) as e:
        print(f"Failed to access log directory in: {PYMAP_LOGDIR}, reason: {e}")
        sys.exit(1)


def verify_secret_key() -> None:
    """
    Verify the SECRET_KEY is provided and set to an appropriate value.

    Raises:
        ValueError: If SECRET_KEY is missing in production environment.
    """
    global SECRET_KEY
    if SECRET_KEY is None and DJANGO_ENV == "production":
        print(
            "You need to provide SECRET_KEY from either the config.json file or a .secret file in the app directory"
        )
        sys.exit(1)
    elif SECRET_KEY is None:
        SECRET_KEY = get_random_secret_key()
        print(f"Generated new secret key {SECRET_KEY}")


# Load custom settings, secret file, and env variables
load_settings_file()
# We only try to load .secret during production to ease development
if DJANGO_ENV == "production":
    load_key_file()
load_settings_env()
# Call the check_log_directory function during startup
check_log_directory()
# Check the SECRET_KEY during startup
verify_secret_key()
